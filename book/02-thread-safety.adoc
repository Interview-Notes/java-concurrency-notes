[[thread-safety]]
== 线程安全性

在线程安全性的定义中，最核心的概念就是正确性。
 2014-05-06
正确性的含义是，某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Postcondition）来描述对象操作的结果。
 2015-06-10
正确性的含义是，某个类的行为与其规范完全一致。
 2015-06-10
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
 2014-05-06
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
 2017-03-04
在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
 2015-06-10
在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
 2017-03-04
由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对象是线程安全的。
 2017-03-04
无状态对象一定是线程安全的。
 2017-03-04
在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition）。
 2017-03-04
当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。
 2017-03-04
最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。
 2017-03-04
要获得正确的结果（与朋友会面），必须取决于事件的发生时序
 2017-03-04
这种观察结果的失效就是大多数竞态条件的本质—基于一种可能失效的观察结果来做出判断或者执行某个计算。这种类型的竞态条件称为“先检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。
 2017-03-04
使用“先检查后执行”的一种常见情况就是延迟初始化。
 2017-03-04
竞态条件并不总是会产生错误，还需要某种不恰
 2014-05-06
假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。
 2017-03-04
当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。
 2017-03-04
当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单。
 2014-05-06
在实际情况中，应尽可能地使用现有的线程安全对象（例如AcomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。
 2017-03-04
在线程安全性的定义中要求，多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。
 2014-05-06
要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。
 2014-05-06
Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。
 2014-05-06
同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。
 2014-05-06
以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。
 2014-05-06
每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。
 2017-03-04
线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。
 2014-05-06
获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。
 2017-03-04
Java的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。
 2017-03-04
由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块时也不会相互干扰。
 2017-03-04
任何一个执行同步代码块的线程，都不可能看到有其他线程正在执行由同一个锁保护的同步代码块。
 2014-05-06
当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。
 2014-05-06
然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。
 2017-03-04
重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。
 2017-03-04
访问共享状态的复合操作，例如命中计数器的递增操作（读取-修改-写入）或者延迟初始化（先检查后执行），都必须是原子操作以避免产生竞态条件。
 2014-05-06
如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。
 2014-05-06
一种常见的错误是认为，只有在写入共享变量时才需要使用同步，然而事实并非如此
 2014-05-06
对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。
 2014-05-06
当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。
 2017-03-04
之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。
 2014-05-06
每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
 2014-05-06
一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。
 2014-05-06
并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。
 2014-05-06
当类的不变性条件涉及多个状态变量时，那么还有另外一个需求：在不变性条件中的每个变量都必须由同一个锁来保护。
 2014-05-06
对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
 2017-03-04
将每个方法都作为同步方法还可能导致活跃性问题（Liveness）或性能问题（Performance）
 2014-05-06
要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。
 2014-05-06
对在单个变量上实现原子操作来说，原子变量是很有用的，但由于我们已经使用了同步代码块来构造原子操作，而使用两种不同的同步机制不仅会带来混乱，也不会在性能或安全性上带来任何好处，因此在这里不使用原子变量。
 2014-05-06
要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（这个需求必须得到满足）、简单性和性能。
 2014-05-06
通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。
 2014-05-06
当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。
 2014-05-06
当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。
 2014-05-07
