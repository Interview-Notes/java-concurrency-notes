[[sharing-objects]]
== 共享对象

要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要进行正确的管理。
 2017-03-04
同步代码块和同步方法可以确保以原子的方式执行操作
 2017-03-04
一种常见的误解是，认为关键字synchronized只能用于实现原子性或者确定“临界区（Critical Section）”。同步还有另一个重要的方面：内存可见性（Memory Visibility）。
 2014-05-07
同步还有另一个重要的方面：内存可见性（Memory Visibility）。
 2014-05-07
我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。
 2014-05-07
一种更奇怪的现象是，NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序（Reordering）”。
 2014-05-07
在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。
 2017-03-04
要对那些缺乏足够同步的并发程序的执行情况进行推断是十分困难的。
 2014-05-07
有一种简单的方法能避免这些复杂的问题：只要有数据在多个线程之间共享，就使用正确的同步。
 2014-05-07
失效数据。当读线程查看ready变量时，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。
 2014-05-07
最低安全性（out-of-thin-air safety）
 2014-05-07
最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（double和long
 2014-05-07
Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。
 2014-05-07
即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。
 2017-03-04
内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果
 2014-05-07
在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下读取某个变量，那么读到的可能是一个失效值。
 2014-05-07
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。
 2017-03-04
Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。
 2017-03-04
volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
 2014-05-07
在读取volatile类型的变量时总会返回最新写入的值。
 2014-05-07
volatile变量对可见性的影响比volatile变量本身更为重要。
 2014-05-07
不建议过度依赖volatile变量提供的可见性。
 2014-05-07
仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。
 2014-05-07
如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。
 2014-05-07
volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生
 2014-05-07
volatile变量通常用做某个操作完成、发生中断或者状态的标志
 2014-05-07
volatile的语义不足以确保递增操作（count++）的原子性，除非你能确保只有一个线程对变量执行写操作。
 2014-05-07
加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。
 2017-03-04
当且仅当满足以下所有条件时，才应该使用volatile变量： 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 该变量不会与其他状态变量一起纳入不变性条件中。 在访问变量时不需要加锁。
 2014-05-07
“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。
 2017-03-04
发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。
 2014-05-07
当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。
 2014-05-07
发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象
 2014-05-07
当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。
 2014-05-07
一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。
 2017-03-04
当把一个对象传递给某个外部方法时，就相当于发布了这个对象。
 2017-03-04
当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。
 2017-03-04
最后一种发布对象或其内部状态的机制就是发布一个内部的类实例
 2017-03-04
public class ThisEscape { public ThisEscape(EventSource source) { source.registerListener( new EventListener() { public void onEvent(Event e) { doSomething(e); } }); } }
注: 请问，怎么从 EventListener 对象上获取 ThisEscape 对象？
 2017-03-04
线程封闭技术的另一种常见应用是JDBC（Java Database Connectivity）的Connection对象。JDBC规范并不要求Connection对象必须是线程安全的。在典型的服务器应用程序中，线程从连接池中获得一个Connection对象，并且用该对象来处理请求，使用完后再将对象返还给连接池。由于大多数请求（例如Servlet请求或EJB调用等）都是由单个线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。
 2017-03-04
栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。
 2017-03-04
局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭（也被称为线程内部使用或者线程局部使用，不要与核心类库中的ThreadLocal混淆）比Ad-hoc线程封闭更易于维护，也更加健壮。
 2017-03-04
如果在线程内部（Within-Thread）上下文中使用非线程安全的对象，那么该对象仍然是线程安全的。
 2017-03-04
维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。
 2017-03-04
ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。
 2017-03-04
当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。
 2017-03-04
当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。
 2017-03-04
在实现应用程序框架时大量使用了ThreadLocal。
 2017-03-04
ThreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。
 2017-03-04
满足同步需求的另一种方法是使用不可变对象（Immutable Object）[EJ Item 13]。
 2017-03-04
如果对象的状态不会改变，那么这些问题与复杂性也就自然消失了。
 2017-03-04
如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。
 2017-03-04
不可变对象一定是线程安全的。
 2017-03-04
不可变对象很简单。
 2017-03-04
在程序设计中，一个最困难的地方就是判断复杂对象的可能状态。
 2017-03-04
不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。
 2017-03-04
当满足以下条件时，对象才是不可变的： 对象创建以后其状态就不能修改。 对象的所有域都是final类型。 对象是正确创建的（在对象的创建期间，this引用没有逸出）。
 2017-03-04
在“不可变的对象”与“不可变的对象引用”之间存在着差异。保存在不可变对象中的程序状态仍然可以更新，即通过将一个保存新状态的实例来“替换”原有的不可变对象。
 2017-03-04
final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。然而，在Java内存模型中，final域还有着特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。
 2017-03-04
正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”[EJ Item 12]是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。
 2017-03-04
在某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。
 2017-03-04
你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。
 2017-03-04
由于没有使用同步来确保Holder对象对其他线程可见，因此将Holder称为“未被正确发布”。
 2017-03-04
在未被正确发布的对象中存在两个问题。首先，除了发布对象的线程外，其他线程可以看到的Holder域是一个失效值，因此将看到一个空引用或者之前的旧值。然而，更糟糕的情况是，线程看到Holder引用的值是最新的，但Holder状态的值却是失效的。
 2017-03-04
情况变得更加不可预测的是，某个线程在第一次读取域时得到失效值，而再次读取这个域时会得到一个更新值，这也是assertSainty抛出AssertionError的原因。
 2017-03-04
Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。
 2017-03-04
为了确保对象状态能呈现出一致的视图，就必须使用同步。
 2017-03-04
即使在发布不可变对象的引用时没有使用同步，也仍然可以安全地访问该对象。为了维持这种初始化安全性的保证，必须满足不可变性的所有需求：状态不可修改，所有域都是final类型，以及正确的构造过程。
 2017-03-04
任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。
 2017-03-04
这种保证还将延伸到被正确创建对象中所有final类型的域。在没有额外同步的情况下，也可以安全地访问final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。
 2017-03-04
可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。
 2017-03-04
要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布： 在静态初始化函数中初始化一个对象引用。 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。 将对象的引用保存到某个正确构造对象的final类型域中。 将对象的引用保存到一个由锁保护的域中。
 2017-03-04
在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如Vector或synchronizedList时，将满足上述最后一条需求。
 2017-03-04
通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。 通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。 通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。
 2017-03-04
通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器： public static Holder holder = new Holder(42); 静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布[JLS 12.4.2]。
 2017-03-04
所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将是可见的，并且如果对象状态不会再改变，那么就足以确保任何访问都是安全的。
 2017-03-04
如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”。
 2017-03-04
通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。
 2017-03-04
在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。
 2017-03-04
如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。要安全地共享可变对象，这些对象就必须被安全地发布，并且必须是线程安全的或者由某个锁保护起来。
 2017-03-04
对象的发布需求取决于它的可变性： 不可变对象可以通过任意机制来发布。 事实不可变对象必须通过安全方式来发布。 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。
 2017-03-04
许多并发错误都是由于没有理解共享对象的这些“既定规则”而导致的。当发布一个对象时，必须明确地说明对象的访问方式。
 2017-03-04
在并发程序中使用和共享对象时，可以使用一些实用的策略，包括： 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。
